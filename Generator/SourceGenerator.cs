using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace REnum.Generator
{
    [Generator]
    public class REnumGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver receiver)
                return;

            foreach (var candidate in receiver.Candidates)
            {
                var model = context.Compilation.GetSemanticModel(candidate.SyntaxTree);
                var symbol = model.GetDeclaredSymbol(candidate);
                if (symbol is not INamedTypeSymbol structSymbol) continue;

                var reEnumAttr = structSymbol.GetAttributes().FirstOrDefault(
                    attr => attr.AttributeClass?.ToDisplayString() == "REnum.REnumAttribute"
                );
                if (reEnumAttr == null) continue;

                List<INamedTypeSymbol> variants = structSymbol.GetAttributes()
                    .Where(attr => attr.AttributeClass?.ToDisplayString() == "REnum.REnumFieldAttribute")
                    .Select(attr => attr.ConstructorArguments.FirstOrDefault().Value)
                    .OfType<INamedTypeSymbol>()
                    .ToList();

                List<string> emptyFields = structSymbol.GetAttributes()
                    .Where(attr => attr.AttributeClass?.ToDisplayString() == "REnum.REnumFieldEmptyAttribute")
                    .Select(attr => attr.ConstructorArguments[0].Value?.ToString())
                    .ToList();

                string unionName = structSymbol.Name;
                string ns = structSymbol.ContainingNamespace.ToDisplayString();
                const string kindEnum = "Kind";

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine($"namespace {ns} {{");
                sb.AppendLine($"public partial struct {unionName} {{");

                // enum
                sb.AppendLine($"    public enum {kindEnum} {{");
                foreach (var variant in variants)
                    sb.AppendLine($"        {variant.Name},");
                foreach (var emptyField in emptyFields)
                    sb.AppendLine($"        {emptyField},");
                sb.AppendLine("    }");

                sb.AppendLine($"    private readonly {kindEnum} _kind;");

                var fields = new Dictionary<INamedTypeSymbol, string>();

                foreach (var variant in variants)
                {
                    string name = $"_{variant.Name.ToLower()}";
                    fields[variant] = name;
                    sb.AppendLine($"    private readonly {variant.ToDisplayString()}? {name};");
                }

                // constructors
                sb.AppendLine($"private {unionName}(");
                sb.AppendLine($"{kindEnum} kind");
                sb.AppendLine(variants.Count > 0 ? "," : "");
                for (int i = 0; i < variants.Count; i++)
                {
                    var variant = variants[i];
                    var typeName = variant.ToDisplayString();
                    var fieldName = variant.Name;
                    var fieldLower = fieldName.ToLower();

                    string comma = i < variants.Count - 1 ? "," : "";
                    sb.AppendLine($"{typeName}? {fieldLower} = null{comma}");
                }
                sb.AppendLine("){");
                sb.AppendLine("_kind = kind;");
                for (int i = 0; i < variants.Count; i++)
                {
                    var variant = variants[i];
                    var argName = variant.Name;
                    var argLower = argName.ToLower();
                    var fieldName = fields[variant];

                    sb.AppendLine($"{fieldName} = {argLower};");
                }
                sb.AppendLine("}");

                foreach (var variant in variants)
                {
                    var typeName = variant.ToDisplayString();
                    var fieldName = variant.Name;
                    var fieldLower = fieldName.ToLower();

                    string kind = $"{kindEnum}.{fieldName}";

                    sb.AppendLine(
                        $"    public static {unionName} From{fieldName}({typeName} value) => new {unionName}({kind}, {fieldLower}: value);"
                    );
                }

                foreach (var emptyField in emptyFields)
                {
                    string kind = $"{kindEnum}.{emptyField}";
                    sb.AppendLine($"    public static {unionName} {emptyField}() => new {unionName}({kind});");
                }

                // matchers
                foreach (var variant in variants)
                {
                    var typeName = variant.ToDisplayString();
                    var fieldName = variant.Name;
                    var fieldLower = fieldName.ToLower();

                    sb.AppendLine($"    public bool Is{fieldName}(out {typeName}? value) {{");
                    sb.AppendLine($"        value = _{fieldLower};");
                    sb.AppendLine($"        return _kind == {kindEnum}.{fieldName};");
                    sb.AppendLine("    }");
                }

                foreach (var emptyField in emptyFields)
                {
                    sb.AppendLine($"    public bool Is{emptyField}() => _kind == {kindEnum}.{emptyField};");
                }

                // Match method
                sb.AppendLine("    public T Match<TCtx, T>(");
                sb.AppendLine($"        TCtx ctx,");
                for (int i = 0; i < variants.Count; i++)
                {
                    var variant = variants[i];
                    var typeName = variant.ToDisplayString();
                    var fieldName = variant.Name;
                    var comma = i < variants.Count - 1 || emptyFields.Count > 0 ? "," : "";
                    sb.AppendLine($"        System.Func<TCtx, {typeName}, T> on{fieldName}{comma}");
                }
                for (int i = 0; i < emptyFields.Count; i++)
                {
                    var emptyField = emptyFields[i];
                    var fieldName = emptyField;
                    var comma = i < emptyFields.Count - 1 ? "," : "";
                    sb.AppendLine($"        System.Func<TCtx, T> on{fieldName}{comma}");
                }
                sb.AppendLine("    )");
                sb.AppendLine("    {");
                sb.AppendLine("        return _kind switch");
                sb.AppendLine("        {");
                foreach (var variant in variants)
                {
                    var fieldName = variant.Name;
                    var fieldLower = fieldName.ToLower();
                    sb.AppendLine(
                        variant.IsValueType
                            ? $"            {kindEnum}.{fieldName} => on{fieldName}(ctx, _{fieldLower}!.Value),"
                            : $"            {kindEnum}.{fieldName} => on{fieldName}(ctx, _{fieldLower}),"
                    );
                }
                foreach (var emptyField in emptyFields)
                {
                    var fieldName = emptyField;
                    sb.AppendLine($"            {kindEnum}.{fieldName} => on{fieldName}(ctx),");
                }
                sb.AppendLine("            _ => throw new System.InvalidOperationException()");
                sb.AppendLine("        };");
                sb.AppendLine("    }");

                // Match method without TCtx
                sb.AppendLine("    public T Match<T>(");
                for (int i = 0; i < variants.Count; i++)
                {
                    var variant = variants[i];
                    var typeName = variant.ToDisplayString();
                    var fieldName = variant.Name;
                    var comma = i < variants.Count - 1 || emptyFields.Count > 0 ? "," : "";
                    sb.AppendLine($"        System.Func<{typeName}, T> on{fieldName}{comma}");
                }
                for (int i = 0; i < emptyFields.Count; i++)
                {
                    var emptyField = emptyFields[i];
                    var fieldName = emptyField;
                    var comma = i < emptyFields.Count - 1 ? "," : "";
                    sb.AppendLine($"        System.Func<T> on{fieldName}{comma}");
                }
                sb.AppendLine("    )");
                sb.AppendLine("    {");
                sb.AppendLine("        return _kind switch");
                sb.AppendLine("        {");
                foreach (var variant in variants)
                {
                    var fieldName = variant.Name;
                    var fieldLower = fieldName.ToLower();
                    sb.AppendLine(
                        variant.IsValueType
                            ? $"            {kindEnum}.{fieldName} => on{fieldName}(_{fieldLower}!.Value),"
                            : $"            {kindEnum}.{fieldName} => on{fieldName}(_{fieldLower}),"
                    );
                }
                foreach (var emptyField in emptyFields)
                {
                    var fieldName = emptyField;
                    sb.AppendLine($"            {kindEnum}.{fieldName} => on{fieldName}(),");
                }
                sb.AppendLine("            _ => throw new System.InvalidOperationException()");
                sb.AppendLine("        };");
                sb.AppendLine("    }");

                // ToString
                sb.AppendLine("    public override string ToString() => _kind switch");
                sb.AppendLine("    {");
                foreach (var variant in variants)
                {
                    var fieldName = variant.Name;
                    var fieldLower = fieldName.ToLower();
                    sb.AppendLine($"        {kindEnum}.{fieldName} => _{fieldLower}?.ToString() ?? \"null\",");
                }
                foreach (var emptyField in emptyFields)
                {
                    var fieldName = emptyField;
                    sb.AppendLine($"        {kindEnum}.{fieldName} => \"{fieldName}\",");
                }
                sb.AppendLine("        _ => \"<invalid>\"");
                sb.AppendLine("    };");

                // Equals (typed)
                sb.AppendLine($"    public bool Equals({unionName} other)");
                sb.AppendLine("    {");
                sb.AppendLine("        if (_kind != other._kind) return false;");
                foreach (var variant in variants)
                {
                    var fieldName = variant.Name;
                    var fieldLower = fieldName.ToLower();
                    var nullable = variant.IsValueType ? "?" : "";
                    sb.AppendLine($"        if (_kind == {kindEnum}.{fieldName})");
                    sb.AppendLine(
                        $"            return System.Collections.Generic.EqualityComparer<{variant.ToDisplayString()}{nullable}>.Default.Equals(_{fieldLower}, other._{fieldLower});"
                    );
                }
                foreach (var emptyField in emptyFields)
                {
                    var fieldName = emptyField;
                    sb.AppendLine($"        if (_kind == {kindEnum}.{fieldName})");
                    sb.AppendLine("            return true;");
                }
                sb.AppendLine("        return false;");
                sb.AppendLine("    }");

                // Equals (object override)
                sb.AppendLine("    public override bool Equals(object? obj) => obj is " + unionName + " other && Equals(other);");

                // GetHashCode
                sb.AppendLine("    public override int GetHashCode()");
                sb.AppendLine("    {");
                sb.AppendLine("        return _kind switch");
                sb.AppendLine("        {");
                foreach (var variant in variants)
                {
                    var fieldName = variant.Name;
                    var fieldLower = fieldName.ToLower();
                    sb.AppendLine($"            {kindEnum}.{fieldName} => System.HashCode.Combine((int)_kind, _{fieldLower}),");
                }
                foreach (var emptyField in emptyFields)
                {
                    var fieldName = emptyField;
                    sb.AppendLine($"            {kindEnum}.{fieldName} => (int)_kind,");
                }
                sb.AppendLine("            _ => 0");
                sb.AppendLine("        };");
                sb.AppendLine("    }");

                // Equality operators
                sb.AppendLine($"    public static bool operator ==({unionName} left, {unionName} right) => left.Equals(right);");
                sb.AppendLine($"    public static bool operator !=({unionName} left, {unionName} right) => !(left == right);");

                sb.AppendLine("}"); // struct
                sb.AppendLine("}"); // namespace

                context.AddSource($"{unionName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            }
        }


        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<StructDeclarationSyntax> Candidates { get; } = new();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is StructDeclarationSyntax structDecl &&
                    structDecl.AttributeLists.Count > 0 &&
                    structDecl.Modifiers.Any(SyntaxKind.PartialKeyword))
                {
                    Candidates.Add(structDecl);
                }
            }
        }
    }
}